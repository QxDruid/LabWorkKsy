# Решение нелинейного уравнения методом Дихотомии
# Делим отрезок пополам и смотрим слева или справа от центра 
# нахоится решение (решение уравнение это пересечение графиком оси Х)
# (то есть в левом или правом отрезке функция проходит через 0
#  т.е меняет на отрезке свой знак с + на - или с - на 6)

# импортируем библиотеки
import numpy as np 
import matplotlib.pyplot as mpl

def f(x):
    return -0.1*x**3+0.14*x**2+1.5*x-1.64

def middle(a, b):
    return (a+b)/2 

def solve(a, b, e):
    # До тех пор пока длина отрезка
    # на котором находится решение не станет меньше требуемой точности
    while (b - a) > e:
        # Делим отрезок пополам
        x = middle(a, b)
        # Смотрим на каком отрезке меняется знак функции 
        if f(a) * f(x) < 0:
            b = x
        elif f(x) * f(b) < 0:
            a = x
    # Записываем решение как середину найденного отрезка
    return middle(a, b)


# Точность нахождения корня
e = 10**(-9)

# Диапазон поиска коря
min = -5
max = 5

# Проходим весь массив от начала до конца с небольштм знаком,
# для того чтоб найти все отрезки на которых функция меняет знак
# (По факту найти количество решений функции на заданном интервале)
x = np.arange(min, max+0.1, 0.5)
points = []
# Задаем первую точку
a = min
for i in x:
    # Смотри меняет ли функция знак
    if f(a)*f(i) < 0:
        # Если да то запоминаем точку
        points.append(i)
        # И переносим начало сканирования дальше
        a = i

# Надодим решение необходимой точности на каждом найденном интервале
a = min
solvs = []
for i in points:
    # Выполняем поиск от начальной точки до следующей
    # И добавляем в массив решений
    solvs.append(solve(a, i, e))
    # Смещаем начальную точку
    a = i
# Выводим решения в консоль
for i in solvs:
    print('%.9f' % i)

# Выводим график функции с отмеченными решениями
zero = [i * 0 for i in solvs]
mpl.plot(solvs, zero,'go')
mpl.plot(np.arange(min, max+0.01, 0.01), [f(x) for x in np.arange(min, max+0.01, 0.01)])
mpl.show()


